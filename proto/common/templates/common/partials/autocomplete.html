{% macro initialiseAutocomplete(suggestions) %}
{#
  WARNING: Thrown together through LLM back and forth. For prototyping purposes only.
  WARNING: Re-write from scratch to build properly, with good testing and sensibly structured.
#}

<style nonce="{{ csp_nonce() }}">
  /* Basic styles for the autocomplete menu */
  .autocomplete-menu {
    position: absolute;
    list-style: none;
    padding: 5px;
    margin: 0;
    border: 1px solid #ccc;
    background: #fff;
    display: none;
    max-height: 250px;
    overflow-y: auto;
    z-index: 1000;
  }
  .autocomplete-menu li {
    padding: 5px 5px;
    font-size: 19px;
    cursor: pointer;
    font-family: GDS Transport,arial,sans-serif;
  }
  .autocomplete-menu li:hover,
  .autocomplete-menu li.selected {
    background-color: SelectedItem;
  }

  /* Styles for the highlighting overlay system */
  .autocomplete-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
  }

  .highlight-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    box-sizing: border-box;
    border: none;
    padding: 7px;
    overflow-y: auto; /* Changed from hidden to auto to match textarea behavior */
    white-space: pre-wrap;
    word-wrap: break-word;
    background: transparent;
    z-index: 0;
    color: black; /* Default text color */

    font-family: "GDS Transport", arial, sans-serif;
    font-feature-settings: normal;
    font-kerning: auto;
    font-optical-sizing: auto;
    font-size: 19px;
    font-size-adjust: none;
    font-stretch: 100%;
    font-style: normal;
    font-variant-alternates: normal;
    font-variant-caps: normal;
    font-variant-east-asian: normal;
    font-variant-emoji: normal;
    font-variant-ligatures: normal;
    font-variant-numeric: normal;
    font-variant-position: normal;
    font-variation-settings: normal;
    font-weight: 400;
    line-height: 1.25em;
    -webkit-font-smoothing: antialiased;

  }

  .highlight-overlay .highlight-match {
    background-color: yellow;
  }

  .autocomplete-input {
    position: relative;
    background-color: transparent !important;
    z-index: 1;
    color: transparent;
    caret-color: black; /* Make cursor visible */
  }
</style>

<script nonce="{{ csp_nonce() }}">
  (function() {
    // List of autocomplete suggestions as objects with `value` and `label`
    const suggestions = {{ suggestions | tojson }};

    // Create and style the autocomplete menu element (shared for all attached inputs)
    const menu = document.createElement("ul");
    menu.className = "autocomplete-menu";
    document.body.appendChild(menu);

    // Position the menu below the input element (for simplicity)
    function positionMenu(inputEl) {
      const rect = inputEl.getBoundingClientRect();
      menu.style.left = (rect.left - 0) + "px";
      menu.style.top = rect.bottom + window.scrollY + "px";
      menu.style.width = (rect.width - 12) + "px";
    }

    // Determine if the cursor is within a (( )) context.
    // Returns an object with the index of "((" and the content between "((" and the cursor.
    function getCurrentContext(text, cursorPos) {
      const openIndex = text.lastIndexOf("((", cursorPos);
      if (openIndex === -1) return null;
      const closeIndex = text.indexOf("))", openIndex);
      if (closeIndex !== -1 && closeIndex < cursorPos) return null;
      return {
        openIndex: openIndex,
        content: text.slice(openIndex + 2, cursorPos)
      };
    }

    // Helper function to find all (( contexts in text (with optional ))
    function findAllContexts(text) {
      const contexts = [];
      let startIndex = 0;

      while (true) {
        const openIndex = text.indexOf("((", startIndex);
        if (openIndex === -1) break;

        const closeIndex = text.indexOf("))", openIndex);

        // If there's no closing )), treat the rest of the text as part of the context
        if (closeIndex === -1) {
          contexts.push({
            openIndex: openIndex,
            closeIndex: text.length,
            content: text.slice(openIndex + 2),
            hasClosing: false
          });
          break; // No need to continue searching
        } else {
          contexts.push({
            openIndex: openIndex,
            closeIndex: closeIndex,
            content: text.slice(openIndex + 2, closeIndex),
            hasClosing: true
          });

          startIndex = closeIndex + 2;
        }
      }

      return contexts;
    }

    function getAutocompleteWord(contextContent) {
      // Check if the cursor is in label mode triggered by a dollar sign '$'.
      const lastDollar = contextContent.lastIndexOf('$');
      if (lastDollar !== -1) {
        return { query: contextContent.slice(lastDollar + 1), mode: "label" };
      }
      // Otherwise, fall back to using the last space-separated token with mode "value".
      const parts = contextContent.split(/\s+/);
      return { query: parts[parts.length - 1], mode: "value" };
    }

    // Fuzzy matching: escape regex, build pattern, and test against value or label.
    function fuzzyMatch(item, queryData) {
      const query = queryData.query;
      const mode = queryData.mode;
      const queryDotCount = (query.match(/\./g) || []).length;
      const itemValue = item.value;
      const itemDotCount = (itemValue.match(/\./g) || []).length;

      if (mode === 'value') {
          // Exclude the item if it's an exact match ending with a dot.
          if (itemValue.endsWith('.') && itemValue === query) {
              return false;
          }

          // For dot-separated paths:
          // Accept if the item's value has exactly the same number of dots as the query,
          // OR if it has one more dot and that extra dot is the last character.
          const dotCondition =
              itemDotCount === queryDotCount ||
              (itemDotCount === queryDotCount + 1 && itemValue.endsWith('.'));

          // Primary condition: the value must satisfy the dot condition and fuzzy-match the query.
          if (dotCondition && itemValue.toLowerCase().startsWith(query.toLowerCase())) {
              return true;
          }
      } else {
          // Helper for fuzzy matching using a regex that allows any characters between query characters.
          function fuzzyRegexMatch(text, patternQuery) {
              const escaped = patternQuery.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
              const pattern = escaped.split('').join('.*');
              const regex = new RegExp(pattern, 'i');
              return regex.test(text);
          }

          // Fallback: if the label is different from the value and the label fuzzy-matches the query.
          if (item.label !== itemValue && fuzzyRegexMatch(item.label, query)) {
              return true;
          }
      }

      return false;
    }

    // Highlight matching letters in the suggestion's label by wrapping them in <b> tags.
    // This function finds the first sequential match of each character in `query` inside `text`.
    function highlightMatch(text, query) {
      let lowerText = text.toLowerCase();
      let lowerQuery = query.toLowerCase();
      let matchIndices = [];
      let startIndex = 0;
      // For each character in the query, find its first occurrence in text after the last match.
      for (let i = 0; i < lowerQuery.length; i++) {
        const ch = lowerQuery[i];
        const idx = lowerText.indexOf(ch, startIndex);
        if (idx === -1) break;
        matchIndices.push(idx);
        startIndex = idx + 1;
      }
      // Build the highlighted string.
      let result = "";
      for (let i = 0; i < text.length; i++) {
        if (matchIndices.includes(i)) {
          result += "<b>" + text[i] + "</b>";
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Function to apply a suggestion: replace the current word in the context.
    function applySuggestion(item, context, inputEl, mode) {
      const text = inputEl.value;
      // Everything before the context start (including the "((")
      const before = text.slice(0, context.openIndex + 2);
      // Everything after the cursor remains unchanged.
      const after = text.slice(inputEl.selectionStart);
      let newContextContent;
      if (mode === "label") {
        // In label mode, remove everything from the '$' that starts label mode onward,
        // then append the suggestion's value.
        const dollarIndex = context.content.lastIndexOf('$');
        newContextContent = context.content.slice(0, dollarIndex) + item.value;
      } else {
        // In value mode, replace the last space-separated token with the suggestion's value.
        const words = context.content.split(/\s+/);
        words[words.length - 1] = item.value;
        newContextContent = words.join(" ");
      }
      inputEl.value = before + newContextContent + after;
      // Place the text cursor at the end of the inserted text (i.e. before "after").
      const newCursorPos = (before + newContextContent).length;
      inputEl.setSelectionRange(newCursorPos, newCursorPos);

      inputEl.focus();
      updateHighlightOverlay(inputEl); // Update highlighting after applying suggestion

      if (item.value.endsWith(".")) {
        // Keep the menu open by triggering an input event.
        inputEl.dispatchEvent(new Event("input"));
      } else {
        menu.style.display = "none";
      }
    }

    // Find and highlight words in the input that match suggestion values
    // ONLY within (( )) contexts
    function updateHighlightOverlay(inputEl) {
      // Get the overlay element
      const wrapper = inputEl.parentElement;
      const overlay = wrapper.querySelector('.highlight-overlay');

      if (!overlay) return;

      const text = inputEl.value;

      // Find all (( )) contexts in the text
      const contexts = findAllContexts(text);

      if (contexts.length === 0) {
        // No contexts to highlight - just use plain text
        overlay.innerHTML = text;
        return;
      }

      // Create a set of all suggestion values for faster lookup
      const suggestionValues = new Set(suggestions.map(item => item.value));

      // Build the highlighted HTML
      let highlightedHTML = '';
      let lastIndex = 0;

      // Process each (( )) context
      for (const context of contexts) {
        // Add text before this context
        highlightedHTML += text.substring(lastIndex, context.openIndex);

        // Add the opening parentheses
        highlightedHTML += '((';

        // Process the content within parentheses
        const contextContent = context.content;

        // Split the content into words and non-words
        const parts = [];
        let currentWord = '';
        let currentNonWord = '';

        for (let i = 0; i < contextContent.length; i++) {
          const char = contextContent[i];
          // Check if the character is part of a word (alphanumeric or .)
          if (/[a-zA-Z0-9._\[\]]/.test(char)) {
            // If we have accumulated non-word characters, add them to parts
            if (currentNonWord) {
              parts.push({
                text: currentNonWord,
                isWord: false
              });
              currentNonWord = '';
            }
            currentWord += char;
          } else {
            // If we have accumulated word characters, add them to parts
            if (currentWord) {
              parts.push({
                text: currentWord,
                isWord: true
              });
              currentWord = '';
            }
            currentNonWord += char;
          }
        }

        // Add any remaining parts
        if (currentWord) {
          parts.push({
            text: currentWord,
            isWord: true
          });
        }
        if (currentNonWord) {
          parts.push({
            text: currentNonWord,
            isWord: false
          });
        }

        // Build the highlighted content for this context
        let contextHTML = '';

        parts.forEach(part => {
          if (part.isWord && suggestionValues.has(part.text) && !part.text.endsWith('.')) {
            // This word exactly matches a suggestion value - highlight it
            contextHTML += `<span class="highlight-match">${part.text}</span>`;
          } else {
            // No match or non-word - add as plain text
            contextHTML += part.text;
          }
        });

        // Add the highlighted context content
        highlightedHTML += contextHTML;

        // Add the closing parentheses only if they exist in the original text
        if (context.hasClosing) {
          highlightedHTML += '))';
          // Update lastIndex to after this context including the closing parentheses
          lastIndex = context.closeIndex + 2;
        } else {
          // If there's no closing )), set lastIndex to the end of text
          lastIndex = text.length;
        }
      }

      // Add any remaining text after the last context
      if (lastIndex < text.length) {
        highlightedHTML += text.substring(lastIndex);
      }

      // Update the overlay
      overlay.innerHTML = highlightedHTML;

      // Ensure scroll position is synchronized
      overlay.scrollTop = inputEl.scrollTop;

      // Ensure overlay dimensions match the input element's current dimensions including padding and border
      overlay.style.width = `${inputEl.offsetWidth}px`;
      overlay.style.height = `${inputEl.offsetHeight}px`;
    }

    // Wrapper function to set up the highlighting overlay
    function setupHighlightingOverlay(inputEl) {
      // Create wrapper container
      const wrapper = document.createElement('div');
      wrapper.className = 'autocomplete-wrapper';

      // Preserve original attributes
      const inputAttributes = {};
      for (let i = 0; i < inputEl.attributes.length; i++) {
        const attr = inputEl.attributes[i];
        inputAttributes[attr.name] = attr.value;
      }

      // Create a copy of the original element's styles
      const computedStyle = window.getComputedStyle(inputEl);
      const inputStyle = {};
      for (let i = 0; i < computedStyle.length; i++) {
        const prop = computedStyle[i];
        inputStyle[prop] = computedStyle.getPropertyValue(prop);
      }

      // Get the original element's dimensions and position
      const rect = inputEl.getBoundingClientRect();

      // Insert wrapper before inputEl in the DOM
      inputEl.parentNode.insertBefore(wrapper, inputEl);

      // Create highlight overlay (for all text rendering and highlighting)
      const highlightOverlay = document.createElement('div');
      highlightOverlay.className = 'highlight-overlay';

      // Add class to input for styling
      inputEl.classList.add('autocomplete-input');

      // Move input to the wrapper
      wrapper.appendChild(highlightOverlay);
      wrapper.appendChild(inputEl);

      // Ensure wrapper dimensions match input
      wrapper.style.width = `${rect.width}px`;

      // Apply initial dimensions to overlay to match the input's full dimensions including padding and border
      highlightOverlay.style.width = `${inputEl.offsetWidth}px`;
      highlightOverlay.style.height = `${inputEl.offsetHeight}px`;

      // Create a ResizeObserver to keep the overlay height in sync with input
      const resizeObserver = new ResizeObserver(entries => {
        for (let entry of entries) {
          if (entry.target === inputEl) {
            // Update overlay dimensions to match the full element size (offsetWidth/Height includes padding and border)
            highlightOverlay.style.width = `${inputEl.offsetWidth}px`;
            highlightOverlay.style.height = `${inputEl.offsetHeight}px`;
          }
        }
      });

      // Start observing the input element for resize changes
      resizeObserver.observe(inputEl);

      // Synchronize overlay scroll with input
      inputEl.addEventListener('scroll', function() {
        highlightOverlay.scrollTop = inputEl.scrollTop;
      });

      return wrapper;
    }

    // Function to handle the auto-closing of parentheses
    function handleAutoClosingParentheses(inputEl) {
      // Keep track of the last two characters typed
      let lastChars = "";

      // Add input event listener to capture typing
      inputEl.addEventListener("input", function(e) {
        const cursorPos = inputEl.selectionStart;
        const text = inputEl.value;

        // Check if we just typed "((" by looking at the current cursor position
        if (cursorPos >= 2 && text.substring(cursorPos - 2, cursorPos) === "((") {
          // Only add "))" if we don't already have a closing parenthesis
          // Check if there's a closing parenthesis ahead
          const textAfterCursor = text.substring(cursorPos);
          const hasClosingParentheses = textAfterCursor.indexOf("))") !== -1;

          // Get the text before and after the cursor
          if (!hasClosingParentheses) {
            const before = text.substring(0, cursorPos);
            const after = text.substring(cursorPos);

            // Insert "))" at the cursor position
            inputEl.value = before + "))" + after;

            // Move the cursor back between the parentheses
            inputEl.setSelectionRange(cursorPos, cursorPos);

            // Trigger update of highlighting overlay
            updateHighlightOverlay(inputEl);
          }
        }
      });
    }

    // Attach the autocomplete functionality to a given input or textarea.
    function attachAutocomplete(inputEl) {
      // Setup the highlighting overlay system
      setupHighlightingOverlay(inputEl);

      // Setup auto-closing parentheses
      handleAutoClosingParentheses(inputEl);

      // Variables for keyboard navigation
      let currentItems = [];
      let selectedIndex = -1;
      let currentContext = null;
      let currentQuery = '';
      let currentMode = 'value';

      // Update the autocomplete menu with filtered suggestions and set default selection.
      function updateMenu(filtered, context, query) {
        if (filtered.length === 0) {
          menu.style.display = "none";
          currentItems = [];
          selectedIndex = -1;
          return;
        }
        currentItems = filtered;
        menu.innerHTML = "";
        filtered.forEach((item, index) => {
          const li = document.createElement("li");
          // Highlight matching letters in the label.
          li.innerHTML = currentMode === 'label' ? highlightMatch(item.label, query) : item.label;
          li.addEventListener("mousedown", function(e) {
            e.preventDefault(); // Prevent input from losing focus
            applySuggestion(item, context, inputEl, currentMode);
          });
          menu.appendChild(li);
        });
        // Highlight the first item by default.
        selectedIndex = 0;
        updateSelection();
        menu.style.display = "block";
        positionMenu(inputEl);
      }

      // Update the visual selection on the menu based on selectedIndex.
      function updateSelection() {
        Array.from(menu.children).forEach((li, index) => {
          if (index === selectedIndex) {
            li.classList.add("selected");
            li.scrollIntoView({ block: "nearest" });
          } else {
            li.classList.remove("selected");
          }
        });
      }

      // Listen for input events.
      inputEl.addEventListener("input", function() {
        const cursorPos = inputEl.selectionStart;
        const text = inputEl.value;

        // Update the highlighting overlay
        updateHighlightOverlay(inputEl);

        currentContext = getCurrentContext(text, cursorPos);
        if (!currentContext) {
          menu.style.display = "none";
          return;
        }
        const result = getAutocompleteWord(currentContext.content);
        if (!result) {
          menu.style.display = "none";
          return;
        }
        currentQuery = result.query;
        currentMode = result.mode;
        // Filter suggestions using fuzzy matching.
        const filtered = suggestions.filter(item => {
            if (currentQuery === item.value && item.value.endsWith(".")) {
              return false;
            }
            return fuzzyMatch(item, result);
        });
        updateMenu(filtered, currentContext, currentQuery);
      });

      // Listen for keyboard events for navigation.
      inputEl.addEventListener("keydown", function(e) {
        if (menu.style.display === "none") return;

        if (e.key === "ArrowDown") {
          e.preventDefault();
          if (currentItems.length === 0) return;
          selectedIndex = (selectedIndex + 1) % currentItems.length;
          updateSelection();
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (currentItems.length === 0) return;
          selectedIndex = (selectedIndex - 1 + currentItems.length) % currentItems.length;
          updateSelection();
        } else if (e.key === "Enter") {
          // If a suggestion is highlighted, apply it.
          if (selectedIndex > -1 && currentItems[selectedIndex] && currentContext) {
            e.preventDefault();
            applySuggestion(currentItems[selectedIndex], currentContext, inputEl, currentMode);
          }
        } else if (e.key === "Escape") {
          // If a suggestion is highlighted, apply it.
          e.preventDefault();
          menu.style.display = "none";
        }
      });

      // Hide the menu when clicking outside of the input or menu.
      document.addEventListener("click", function(e) {
        if (e.target !== inputEl && !menu.contains(e.target)) {
          menu.style.display = "none";
        }
      });

      // Initial update of highlighting
      updateHighlightOverlay(inputEl);
    }

    // Expose the function globally so you can attach it to your input element.
    window.attachAutocomplete = attachAutocomplete;
  })();

  // Automatically initialize autocomplete on elements with data-mhclg-module="autocomplete"
  document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll('[data-mhclg-module="autocomplete"]').forEach(function(inputEl) {
      attachAutocomplete(inputEl);
    });
  });
</script>
{% endmacro %}
